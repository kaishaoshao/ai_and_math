# 从 DFT 到 FFT：数学推导全过程

**快速傅里叶变换（FFT）并不是一种新的变换，它只是离散傅里叶变换（DFT）的一种****快速算法**。它的核心思想是：**分而治之（Divide and Conquer）**。

**如果不使用 FFT，计算一个 N 点的 DFT 需要 $N^2$ 次运算。而使用 FFT，只需要 $N \log_2 N$ 次。**

**下面我们以最经典的 ****基-2 库利-图基（Cooley-Tukey）算法** 为例进行推导。

## 1. 起点：DFT 的定义

**假设我们有一个长度为 $N$ 的时域信号序列 $x[n]$（假设 $N$ 是 2 的幂）。 DFT 的定义公式为：**


**其中，$W_N$ 被称为****旋转因子**（Twiddle Factor），定义为：



> **直觉理解**：$W_N$ 就是复平面上的一个单位圆，被切成了 $N$ 份。$W_N^{nk}$ 就是在这个圆上转圈圈。

## 2. 第一刀：奇偶分组

**为了减少运算量，我们将求和公式里的 $x[n]$ 按照下标的奇偶性拆成两组：**

* **偶数项**：$x[0], x[2], x[4], \dots$ （令 $n = 2r$）
* **奇数项**：$x[1], x[3], x[5], \dots$ （令 $n = 2r + 1$）

**原来的求和公式 $X[k]$ 可以拆写为：**

**

$$
\begin{aligned} X[k] &= \sum***{n \text{ is even}} x[n] W_N^{nk} + \sum*{n \text{ is odd}} x[n] W_N^{nk} \** &= \sum***{r=0}^{N/2-1} x[2r] W_N^{2rk} + \sum*{r=0}^{N/2-1} x[2r+1] W_N^{(2r+1)k} \end{aligned}
$$


**我们将第二项中的 $W_N^{(2r+1)k}$ 拆开：$W_N^{(2r+1)k} = W_N^{2rk} \cdot W_N^k$。 公式变为：**

**

$$
X[k] = \underbrace{\sum***{r=0}^{N/2-1} x[2r] W_N^{2rk}}*{\text{偶数部分}} + W_N^k \cdot \underbrace{\sum*{r=0}^{N/2-1} x[2r+1] W_N^{2rk}}*{\text{奇数部分}}
$$


## 3. 关键转化：旋转因子的性质

**这里用到 FFT 推导中最核心的一个数学性质：****消去引理**。



**也就是说，$N$ ****点 DFT 中的偶数项，其实等同于** $N/2$ **点 DFT。**

**代入上面的公式，我们得到了：**

**

$$
X[k] = \underbrace{\sum***{r=0}^{N/2-1} x[2r] W*{N/2}^{rk}}*{E[k]} + W_N^k \cdot \underbrace{\sum*{r=0}^{N/2-1} x[2r+1] W*{N/2}^{rk}}*{O[k]}
$$


**我们定义：**

* **$E[k]$：偶数点序列 ($x[0], x[2]...$) 的 $N/2$ 点 DFT。**
* **$O[k]$：奇数点序列 ($x[1], x[3]...$) 的 $N/2$ 点 DFT。**

**公式简化为：**



**到这一步的意义**：我们将一个 $N$ 点的大问题，拆成了两个 $N/2$ 点的小问题。

## 4. 终极加速：利用对称性计算后半部分

**上面的公式只解决了 $k = 0, \dots, N/2 - 1$ （前半部分）的计算。 对于后半部分 $k = N/2, \dots, N-1$，我们需要利用旋转因子的****周期性**和**对称性**。

**假设我们要计算 $X[k + N/2]$：**

1. **子 DFT 的周期性**： DFT 的结果是周期的，周期为 $N/2$。
   **E[k + N/2] = E[k]**
   **O[k + N/2] = O[k]**
2. **旋转因子的对称性**：
   **W_N^{k + N/2} = W_N^k \cdot W_N^{N/2}**
   **其中 $W_N^{N/2} = e^{-j \frac{2\pi}{N} \cdot \frac{N}{2}} = e^{-j\pi} = \mathbf{-1}$。 所以：**
   **W_N^{k + N/2} = -W_N^k**

**将这两个性质代入 $X[k]$ 的公式中，计算后半部分 $X[k + N/2]$：**



## 5. 结论：蝶形运算公式

**汇总一下，我们只需要遍历 $k$ 从 $0$ 到 $N/2 - 1$，就可以同时算出两个结果：**

1. **前半部分**：$X[k] = E[k] + W_N^k \cdot O[k]$
2. **后半部分**：$X[k + N/2] = E[k] - W_N^k \cdot O[k]$

**这就是著名的****蝶形运算（Butterfly Operation）**。

* **我们只需要计算一次乘法 $T = W_N^k \cdot O[k]$。**
* **$X[k]$ 是 $E[k]$ 加上 $T$。**
* **$X[k + N/2]$ 是 $E[k]$ 减去 $T$。**

### 对应 C 代码逻辑

```
// data[k] 对应 E[k] (因为是原地运算)
// data[k + m2] 对应 O[k]
// w 对应 W_N^k

Complex u = data[k];      // E[k]
Complex t = w * data[k + m2]; // W * O[k]

data[k] = u + t;          //前半部分
data[k + m2] = u - t;     //后半部分
```

## 6. 进阶：CFFT 与 RFFT 的区别

**上述推导过程是通用的 ****CFFT (复数 FFT)**，它假设输入 $x[n]$ 是复数。 但在实际工程中（如音频处理），输入往往全是**实数**。这时候我们可以使用 **RFFT (实数 FFT)** 来进一步优化。

### 区别概览

| **特性** | **CFFT (复数 FFT)**         | **RFFT (实数 FFT)**               |
| -------------- | --------------------------------- | --------------------------------------- |
| **输入** | **复数数组 (实部+虚部)**    | **实数数组 (仅实部)**             |
| **输出** | **$N$ 个复数 (完整频谱)** | **$N/2 + 1$ 个复数 (仅正频率)** |
| **效率** | **标准**                    | **快约 2 倍**                     |
| **内存** | **标准**                    | **省约 50%**                      |

### 数学原理：共轭对称性

**当输入信号 $x[n]$ 为实数时，其频域结果 $X[k]$ 具有****共轭对称性**：



**这意味着：**

* **$X[1]$ 和 $X[N-1]$ 实部相等，虚部相反。**
* **$X[2]$ 和 $X[N-2]$ 实部相等，虚部相反。**
* **...**

**结论**：对于实数信号，我们只需要计算前 $N/2 + 1$ 个点（正频率部分），剩下的 $N/2$ 个点（负频率部分）是完全冗余的。RFFT 正是利用这一性质，去掉了这一半的计算量和存储需求。
